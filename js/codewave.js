// Generated by CoffeeScript 1.8.0
(function() {
  var __slice = [].slice;

  this.Codewave = (function() {
    function Codewave(editor) {
      this.editor = editor;
      this.brakets = '~~';
      this.deco = '~';
      this.closeChar = '/';
      this.noExecuteChar = '!';
      this.carretChar = '|';
      this.nameSpaces = [];
      this.checkCarret = true;
      this.vars = {};
      this.editor.onActivationKey = (function(_this) {
        return function() {
          return _this.onActivationKey();
        };
      })(this);
    }

    Codewave.prototype.onActivationKey = function() {
      var cmd, cpos, _ref;
      console.log('activation key');
      if ((cmd = (_ref = this.commandOnCursorPos()) != null ? _ref.init() : void 0)) {
        console.log(cmd);
        return cmd.execute();
      } else {
        cpos = this.editor.getCursorPos();
        if (cpos.start === cpos.end) {
          return this.addBrakets(cpos.start, cpos.end);
        } else {
          return this.promptClosingCmd(cpos.start, cpos.end);
        }
      }
    };

    Codewave.prototype.commandOnCursorPos = function() {
      var cpos;
      cpos = this.editor.getCursorPos();
      return this.commandOnPos(cpos.end);
    };

    Codewave.prototype.commandOnPos = function(pos) {
      var next, prev;
      prev = this.editor.textSubstr(pos - this.brakets.length, pos) === this.brakets ? pos - this.brakets.length : this.findPrevBraket(this.isEndLine(pos) ? pos : pos + 1);
      if (prev == null) {
        return null;
      }
      if (prev > pos - this.brakets.length) {
        pos = prev;
        prev = this.findPrevBraket(pos);
      }
      next = this.findNextBraket(pos);
      console.log(next);
      if (!((next != null) && this.countPrevBraket(prev) % 2 === 0)) {
        return null;
      }
      return new Codewave.CmdInstance(this, prev, this.editor.textSubstr(prev, next + this.brakets.length));
    };

    Codewave.prototype.nextCmd = function(start) {
      var beginning, f, pos;
      if (start == null) {
        start = 0;
      }
      pos = start;
      while (f = this.findAnyNext(pos, [this.brakets, "\n"])) {
        pos = f.pos + f.str.length;
        if (f.str === this.brakets) {
          if (typeof beginning !== "undefined" && beginning !== null) {
            return new Codewave.CmdInstance(this, beginning, this.editor.textSubstr(beginning, f.pos + this.brakets.length));
          } else {
            beginning = f.pos;
          }
        } else {
          beginning = null;
        }
      }
      return null;
    };

    Codewave.prototype.getEnclosingCmd = function(pos) {
      var closingPrefix, cmd, cpos, p;
      if (pos == null) {
        pos = 0;
      }
      cpos = pos;
      closingPrefix = this.brakets + this.closeChar;
      while ((p = this.findNext(cpos, closingPrefix)) != null) {
        if (cmd = this.commandOnPos(p + closingPrefix.length)) {
          cpos = cmd.getEndPos();
          if (cmd.pos < pos) {
            return cmd;
          }
        } else {
          cpos = p + closingPrefix.length;
        }
      }
      return null;
    };

    Codewave.prototype.countPrevBraket = function(start) {
      var i;
      i = 0;
      while (start = this.findPrevBraket(start)) {
        i++;
      }
      return i;
    };

    Codewave.prototype.isEndLine = function(pos) {
      return this.editor.textSubstr(pos, pos + 1) === "\n" || pos + 1 >= this.editor.textLen();
    };

    Codewave.prototype.findLineStart = function(pos) {
      var p;
      p = this.findAnyNext(pos, ["\n"], -1);
      if (p) {
        return p.pos + 1;
      } else {
        return 0;
      }
    };

    Codewave.prototype.findPrevBraket = function(start) {
      return this.findNextBraket(start, -1);
    };

    Codewave.prototype.findNextBraket = function(start, direction) {
      var f;
      if (direction == null) {
        direction = 1;
      }
      f = this.findAnyNext(start, [this.brakets, "\n"], direction);
      if (f && f.str === this.brakets) {
        return f.pos;
      }
    };

    Codewave.prototype.findPrev = function(start, string) {
      return this.findNext(start, string, -1);
    };

    Codewave.prototype.findNext = function(start, string, direction) {
      var f;
      if (direction == null) {
        direction = 1;
      }
      f = this.findAnyNext(start, [string], direction);
      if (f) {
        return f.pos;
      }
    };

    Codewave.prototype.findAnyNext = function(start, strings, direction) {
      var end, pos, str, _i, _len, _ref, _ref1;
      if (direction == null) {
        direction = 1;
      }
      pos = start;
      while (true) {
        if (!((0 <= pos && pos < this.editor.textLen()))) {
          return null;
        }
        for (_i = 0, _len = strings.length; _i < _len; _i++) {
          str = strings[_i];
          _ref = [pos, pos + str.length * direction], start = _ref[0], end = _ref[1];
          if (end < start) {
            _ref1 = [end, start], start = _ref1[0], end = _ref1[1];
          }
          if (str === this.editor.textSubstr(start, end)) {
            return {
              str: str,
              pos: direction < 0 ? pos - str.length : pos
            };
          }
        }
        pos += direction;
      }
    };

    Codewave.prototype.findMatchingPair = function(startPos, opening, closing, direction) {
      var f, nested, pos;
      if (direction == null) {
        direction = 1;
      }
      pos = startPos;
      nested = 0;
      while (f = this.findAnyNext(pos, [closing, opening], direction)) {
        pos = f.pos + (direction > 0 ? f.str.length : 0);
        if (f.str === (direction > 0 ? closing : opening)) {
          if (nested > 0) {
            nested--;
          } else {
            return f;
          }
        } else {
          nested++;
        }
      }
      return null;
    };

    Codewave.prototype.addBrakets = function(start, end) {
      this.editor.insertTextAt(this.brakets, end);
      this.editor.insertTextAt(this.brakets, start);
      return this.editor.setCursorPos(end + this.brakets.length);
    };

    Codewave.prototype.promptClosingCmd = function(start, end) {
      if (this.closingPromp != null) {
        this.closingPromp.stop();
      }
      return this.closingPromp = new Codewave.ClosingPromp(this, start, end);
    };

    Codewave.prototype.parseAll = function(recursive) {
      var cmd, parser, pos;
      if (recursive == null) {
        recursive = true;
      }
      pos = 0;
      while (cmd = this.nextCmd(pos)) {
        pos = cmd.getEndPos();
        this.editor.setCursorPos(pos);
        if (recursive && (cmd.content != null)) {
          parser = new Codewave(new Codewave.TextParser(cmd.content));
          cmd.content = parser.parseAll();
        }
        if (cmd.init().execute() != null) {
          if ((cmd.replaceEnd != null)) {
            pos = cmd.replaceEnd;
          } else {
            pos = this.editor.getCursorPos().end;
          }
        }
      }
      return this.getText();
    };

    Codewave.prototype.getText = function() {
      return this.editor.text();
    };

    Codewave.prototype.getNameSpaces = function() {
      return ['core'].concat(this.nameSpaces);
    };

    Codewave.prototype.addNameSpace = function(name) {
      return this.nameSpaces.push(name);
    };

    Codewave.prototype.removeNameSpace = function(name) {
      return this.nameSpaces = this.nameSpaces.filter(function(n) {
        return n !== name;
      });
    };

    Codewave.prototype.getCmd = function(cmdName, nameSpaces) {
      if (nameSpaces == null) {
        nameSpaces = [];
      }
      return this.getCmdFrom(cmdName, Codewave, this.getNameSpaces().concat(nameSpaces));
    };

    Codewave.prototype.uniformizeCmd = function(cmd) {
      if (typeof cmd === "function") {
        if ((cmd.prototype.execute != null) || (cmd.prototype.result != null)) {
          return {
            cls: cmd
          };
        } else {
          return {
            result: cmd
          };
        }
      } else if (typeof cmd === 'string') {
        return {
          result: cmd
        };
      } else {
        return cmd;
      }
    };

    Codewave.prototype.prepCmd = function(cmd, path) {
      var aliassed;
      if (path == null) {
        path = [];
      }
      if ((cmd != null)) {
        cmd = this.uniformizeCmd(cmd);
        cmd.fullname = path.join(':');
        if ((cmd.aliasOf != null) && ((aliassed = this.getCmd(cmd.aliasOf)) != null)) {
          cmd = Codewave.util.merge(cmd, aliassed);
          cmd.aliassed = aliassed;
        }
        return cmd;
      }
    };

    Codewave.prototype.getCmdFrom = function(cmdName, space, nameSpaces, path) {
      var cmd, cmdNameAfter, cmdNameSpc, nspc, p, spc, _i, _len, _ref;
      if (path == null) {
        path = [];
      }
      if ((space != null) && (space.cmd != null)) {
        if ((p = cmdName.indexOf(':')) > -1) {
          cmdNameSpc = cmdName.substring(0, p);
          cmdNameAfter = cmdName.substring(p + 1);
        }
        _ref = nameSpaces.reverse();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          nspc = _ref[_i];
          spc = Codewave.getNameSpace(nspc, space);
          if (cmd = this.getCmdFrom(cmdName, spc, nameSpaces, path.concat([nspc]))) {
            return cmd;
          }
        }
        if (cmdNameSpc != null) {
          if (cmd = this.getCmdFrom(cmdNameAfter, space.cmd[cmdNameSpc], nameSpaces, path.concat([cmdNameSpc]))) {
            return cmd;
          }
        } else if (space.cmd[cmdName] != null) {
          return this.prepCmd(space.cmd[cmdName], path.concat([cmdName]));
        }
      }
    };

    Codewave.prototype.getCommentChar = function() {
      return '<!-- %s -->';
    };

    Codewave.prototype.wrapComment = function(str) {
      var cc;
      cc = this.getCommentChar();
      if (cc.indexOf('%s') > -1) {
        return cc.replace('%s', str);
      } else {
        return cc + ' ' + str + ' ' + cc;
      }
    };

    Codewave.prototype.wrapCommentLeft = function(str) {
      var cc, i;
      if (str == null) {
        str = '';
      }
      cc = this.getCommentChar();
      console.log();
      if ((i = cc.indexOf('%s')) > -1) {
        return cc.substr(0, i) + str;
      } else {
        return cc + ' ' + str;
      }
    };

    Codewave.prototype.wrapCommentRight = function(str) {
      var cc, i;
      if (str == null) {
        str = '';
      }
      cc = this.getCommentChar();
      if ((i = cc.indexOf('%s')) > -1) {
        return str + cc.substr(i + 2);
      } else {
        return str + ' ' + cc;
      }
    };

    Codewave.prototype.removeCarret = function(str) {
      var re;
      re = new RegExp(Codewave.util.escapeRegExp(this.carretChar), "g");
      return str.replace(re, '');
    };

    return Codewave;

  })();

  this.Codewave.getNameSpace = function(nspc, startSpace) {
    var parts, pt, spc, _i, _len, _ref;
    if (startSpace == null) {
      startSpace = Codewave;
    }
    parts = nspc.split(':');
    spc = startSpace;
    for (_i = 0, _len = parts.length; _i < _len; _i++) {
      pt = parts[_i];
      if (((_ref = spc.cmd) != null ? _ref[pt] : void 0) == null) {
        return null;
      }
      spc = spc.cmd[pt];
    }
    return spc;
  };

  this.Codewave.setCmd = function(fullname, data, save) {
    var name, parts, pt, saved, spc, _i, _len;
    if (save == null) {
      save = true;
    }
    parts = fullname.split(':');
    name = parts.pop();
    spc = Codewave;
    for (_i = 0, _len = parts.length; _i < _len; _i++) {
      pt = parts[_i];
      if (spc.cmd[pt] == null) {
        spc.cmd[pt] = {};
      }
      spc = spc.cmd[pt];
      if (spc.cmd == null) {
        spc.cmd = {};
      }
    }
    spc.cmd[name] = data;
    if (save) {
      saved = Codewave.storage.load('saved');
      if (saved == null) {
        saved = {};
      }
      saved[fullname] = data;
      Codewave.storage.save('saved', saved);
    }
    return data;
  };

  this.Codewave.util = {
    escapeRegExp: function(str) {
      return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
    },
    merge: function() {
      var xs;
      xs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if ((xs != null ? xs.length : void 0) > 0) {
        return Codewave.util.tap({}, function(m) {
          var k, v, x, _i, _len, _results;
          _results = [];
          for (_i = 0, _len = xs.length; _i < _len; _i++) {
            x = xs[_i];
            _results.push((function() {
              var _results1;
              _results1 = [];
              for (k in x) {
                v = x[k];
                _results1.push(m[k] = v);
              }
              return _results1;
            })());
          }
          return _results;
        });
      }
    },
    tap: function(o, fn) {
      fn(o);
      return o;
    }
  };

}).call(this);

//# sourceMappingURL=codewave.js.map
